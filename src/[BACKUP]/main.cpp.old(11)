
#include <../lib/Time-master/TimeLib.h>
#include <../lib/pubsubclient-2.8/src/PubSubClient.h>
#include <../include/Creds/WifiCred.h>
#include <../include/Creds/HiveMQCred.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoOTA.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPClient.h>

#define DEVICE_NAME "Adler"
bool a = false;

// DS8
#define ONE_WIRE_BUS 0
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature tempSensor(&oneWire);
DeviceAddress sensorAddress;

#define serverPort 80 // Web server port (default is 80)
#define IR_SEND_PIN 13
#define DISABLE_CODE_FOR_RECEIVER
#include <IRremote.hpp>
ESP8266WebServer server(serverPort);
uint oldTime = 0;
double _current_temp = 0;
void sendIR(uint32_t);
// TCP Definitions
WiFiClientSecure hive_client;
PubSubClient HiveMQ(hive_client);
#define DEBUG // comment for power efficiency

#pragma region OTA
void startOTA()
{
#ifdef DEBUG
  String type;
  // caso a atualização esteja sendo gravada na memória flash externa, então informa "flash"
  if (ArduinoOTA.getCommand() == U_FLASH)
    type = "flash";
  else                   // caso a atualização seja feita pela memória interna (file system), então informa "filesystem"
    type = "filesystem"; // U_SPIFFS
  // exibe mensagem junto ao tipo de gravação
  Serial.println("Start updating " + type);
#endif
}
// exibe mensagem
void endOTA()
{
#ifdef DEBUG
  Serial.println("\nEnd");
#endif
}
// exibe progresso em porcentagem
void progressOTA(unsigned int progress, unsigned int total)
{
#ifdef DEBUG
  Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
#endif
}

void errorOTA(ota_error_t error)
{
#ifdef DEBUG
  Serial.printf("Error[%u]: ", error);
  if (error == OTA_AUTH_ERROR)
    Serial.println("Auth Failed");
  else if (error == OTA_BEGIN_ERROR)
    Serial.println("Begin Failed");
  else if (error == OTA_CONNECT_ERROR)
    Serial.println("Connect Failed");
  else if (error == OTA_RECEIVE_ERROR)
    Serial.println("Receive Failed");
  else if (error == OTA_END_ERROR)
    Serial.println("End Failed");
#endif
}
#pragma endregion

struct Internals
{
  bool time_synced = false;
  uint boot_time = 0;

  String toString()
  {
    String result = "time_synced: " + String(time_synced) + ";boot_time: " + String(boot_time) + ";life: " + String(now() - boot_time);
    return result;
  }
};

struct Timers_Last_Values
{
  uint temperature = 0;
  uint sync_time = 0;
  uint mqtt_publish = 0;
  uint mqtt_reconnect = 0;
};
Timers_Last_Values Timers;

Internals control_variables;

#pragma region Server
void handleIRSend()
{
  Serial.printf("%d\n", server.args());
  sendIR(0x10001);
}
void handleRoot()
{
  String message =
      //##$$page.html

      R"===(<!DOCTYPE html>
<html>

<head>
    <title>Adler IR Remote</title>
    <link rel="preload" href="page.css" as="style"/>
    <link rel="stylesheet" href="page.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script type="text/javascript" src="page.js"></script>
</head>

<body class="outer-div">
    <div class="card-container">
        <div class="card">
            <h2>Send IR Code</h2>
            <div>
                <input type="text" style="margin: 5px; text-align:center" id="ir-code" /><button type="submit" onclick="sendIRCode()">Send</button>
            </div>
        </div>
        <div class="card">
            <h2>Current Temperature</h2>
            <div id="temperatureDiv">Loading...</div>
        </div>
        <div class="card">
            <h5>MQTT Status:</h5>
            <div id="mqttDiv">Loading...</div>
        </div>
        <div class="card">
            <h5>Next Action:</h5>
            <div id="next-actionDiv">Loading...</div>
        </div>
        <div class="card">
            <h5>Current Status:</h5>
            <div id="current-statusDiv">Loading...</div>
        </div>
        <div class="card">
            <div>
                <h6>Synced:</h6>
                <div id="synced-timeDiv">Loading...</div>
            </div>
            <div>
                <h6>Life:</h6>
                <div id="life-timeDiv">Loading...</div>
            </div>
            <div>
                <h6>Boot:</h6>
                <div id="boot-timeDiv">Loading...</div>
            </div>
        </div>
    </div>
</body>

</html>)==="
      //##$$
      ;
  server.send(200, "text/html", message);
}

void handleJS()
{
  String message =
      //##$$page.js

      R"===(var teststr = "temp:0.00;mqtt:0;time_synced: 1;boot_time: 1691624418;life: 260;";
function getDefineName(value) {
    switch (value) {
        case -4:
            return "MQTT_CONNECTION_TIMEOUT";
        case -3:
            return "MQTT_CONNECTION_LOST";
        case -2:
            return "MQTT_CONNECT_FAILED";
        case -1:
            return "MQTT_DISCONNECTED";
        case 0:
            return "MQTT_CONNECTED";
        case 1:
            return "MQTT_CONNECT_BAD_PROTOCOL";
        case 2:
            return "MQTT_CONNECT_BAD_CLIENT_ID";
        case 3:
            return "MQTT_CONNECT_UNAVAILABLE";
        case 4:
            return "MQTT_CONNECT_BAD_CREDENTIALS";
        case 5:
            return "MQTT_CONNECT_UNAUTHORIZED";
        default:
            return "Unknown";
    }
}
function test() {
    console.log(parseInfoData(teststr))
}
// Function to fetch and update the IR codes
function fetchInfoUpdates() {
    fetch('/info').then(response => response.text())
        .then(data => {
            parseInfoData(data);

        })


}
function parseInfoData(responseText) {
    const infoPairs = responseText.split(';');
    const infoData = {};
    infoPairs.forEach(pair => {
        const [name, value] = pair.split(':');
        updateInfoData(name, value);
    });
}

function updateInfoData(name, value) {
    //console.log(name, value);
    if (typeof (name) === undefined)
        return;
    if (name === "temp") {
        const temperatureDiv = document.getElementById('temperatureDiv');
        temperatureDiv.textContent = `${value} \u00B0C`;
    }
    else if (name === "mqtt") {
        var intvalue = parseInt(value);
        const mqttDiv = document.getElementById('mqttDiv');
        mqttDiv.textContent = getDefineName(intvalue);
        if (intvalue === 0) {
            mqttDiv.classList.add("mqtt-good");
            mqttDiv.classList.remove("mqtt-bad");
        }
        else {
            mqttDiv.classList.remove("mqtt-good");
            mqttDiv.classList.add("mqtt-bad");
        }
    }
    else if (name === "time_synced") {
        var intvalue = parseInt(value);
        const thisDiv = document.getElementById('synced-timeDiv');
        thisDiv.textContent = intvalue === 0 ? "Nope" : "Yup";
        if (intvalue === 1) {
            thisDiv.classList.add("mqtt-good");
            thisDiv.classList.remove("mqtt-bad");
        }
        else {
            thisDiv.classList.remove("mqtt-good");
            thisDiv.classList.add("mqtt-bad");
        }
    }
    else if (name === "life") {
        var intvalue = parseInt(value);
        const thisDiv = document.getElementById('life-timeDiv');
        thisDiv.textContent = formatTime(intvalue);

    }
    else if (name === "boot_time") {
        var date = new Date(parseInt(value) * 1000);
        const thisDiv = document.getElementById('boot-timeDiv');
        const options = { year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
        thisDiv.textContent = date.toLocaleString('pt-US', options);

    }

}

function formatTime(seconds) {
    if (seconds < 90) {
        return `${seconds} s`;
    } else if (seconds < 90 * 60) {
        const minutes = Math.floor(seconds / 60);
        return `${minutes} m`;
    } else {
        const hours = Math.floor(seconds / 3600);
        const remainingMinutes = Math.floor((seconds % 3600) / 60);

        if (remainingMinutes === 0) {
            return `${hours} h`;
        } else {
            const formattedMinutes = remainingMinutes < 10 ? `0${remainingMinutes}` : remainingMinutes;
            return `${hours} h ${formattedMinutes} m`;
        }
    }
}

// Fetch IR codes on page load and set an interval to update them periodically
document.addEventListener('DOMContentLoaded', function () {
    fetchInfoUpdates();
    setInterval(fetchInfoUpdates, 500); // Update the codes every 5 seconds (adjust as needed)
});

function updateTemperatureDisplay(temperature) {
    const temperatureDiv = document.getElementById('temperatureDiv');
    temperatureDiv.textContent = `${temperature} \u00B0C`;//+'&deg; C';
}

function sendIRCode() {
    const irInput = document.getElementById("ir-code");

    fetch('/send-ir?code=' + irInput.value)
        .then(response => response.text())
        .then(data => {
            console.log(data);
            // Optionally, update UI with response data
        })
        .catch(error => {
            console.error('Error:', error);
            // Handle error if needed
        });
        irInput.value = "";
}
)==="
      //##$$
      ;
  server.send(200, "text/javascript", message);
}

void handleCSS()
{
  String message =
      //##$$page.css

      R"===(@charset "utf-8";
.outer-div {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
}

/* Style the outer div */
.card-container {
    text-align: center;
    border: 1px solid #ccc;
    padding: 20px;
    border-radius: 10px;
}

/* Style the temperatureDiv */
#temperatureDiv {
    font-size: 24px;
    padding: 10px;
    background-color: #f0f0f0;
    border-radius: 5px;
}

.mqtt-good {
    color: darkgreen;
}

.mqtt-bad {
    color: darkred;
}

.card {
    margin: 5px;
})==="
      //##$$
      ;
  server.send(200, "text/css", message);
}

String getDefineName(int value)
{
  switch (value)
  {
  case -4:
    return "MQTT_CONNECTION_TIMEOUT";
  case -3:
    return "MQTT_CONNECTION_LOST";
  case -2:
    return "MQTT_CONNECT_FAILED";
  case -1:
    return "MQTT_DISCONNECTED";
  case 0:
    return "MQTT_CONNECTED";
  case 1:
    return "MQTT_CONNECT_BAD_PROTOCOL";
  case 2:
    return "MQTT_CONNECT_BAD_CLIENT_ID";
  case 3:
    return "MQTT_CONNECT_UNAVAILABLE";
  case 4:
    return "MQTT_CONNECT_BAD_CREDENTIALS";
  case 5:
    return "MQTT_CONNECT_UNAUTHORIZED";
  default:
    return "Unknown";
  }
}

void handleInfo()
{
  String response = "temp:";
  response += String(_current_temp).substring(0, 4);
  response += ";mqtt:";
  response += HiveMQ.state();
  response += ";";
  response += control_variables.toString();
  response += ";";
  server.send(200, "text/plain", response);
}
#pragma endregion

// Callback for payload at the mqtt topic
void HiveMQ_Callback(char *topic, byte *payload, unsigned int length)
{
  String incommingMessage = "";
  for (int i = 0; i < length; i++)
    incommingMessage += (char)payload[i];

  Serial.printf("MQTT::[%s]-->[%s]\n", topic, incommingMessage.c_str());
  // Only topic Shell will have valid commands and expect a response
  if (strcmp(topic, "Adler/Light") == 0)
  {
    incommingMessage == "1" ? digitalWrite(2, !HIGH) : digitalWrite(2, !LOW);
    incommingMessage == "HIGH" ? digitalWrite(2, !HIGH) : digitalWrite(2, !LOW);
    incommingMessage == "on" ? digitalWrite(2, !HIGH) : digitalWrite(2, !LOW);
  }
}

bool getTime()
{
  bool result = false;
  Serial.println("Syncing Time Online");
  WiFiClient client;
  HTTPClient http;
  http.begin(client, "http://worldtimeapi.org/api/timezone/America/Bahia.txt"); // HTTP
  int httpCode = http.GET();
  // httpCode will be negative on error
  if (httpCode > 0)
  {
    // HTTP header has been send and Server response header has been handled
    // file found at server
    if (httpCode == HTTP_CODE_OK)
    {
      Serial.printf("[HTTP] OK... code: %d\n", httpCode);
      String payload = http.getString();
      char str[payload.length() + 1];
      strcpy(str, payload.c_str());
      char *pch;
      pch = strtok(str, ":\n");
      int i = 0;
      int raw_offset = 0;
      while (pch != NULL)
      {
        i++;
        if (i == 23)
        {
          raw_offset = atoi(pch);
        }
        if (i == 27)
        {
          setTime(atoi(pch) + raw_offset);
        }
        // printf("%d: %s\n", i, pch);
        pch = strtok(NULL, ":\n");
      }
      String msg = "Time Synced ";
      msg += millis();
      msg += "ms from boot.";
      Serial.println(msg);
      result = true;
    }
    else
    {
      Serial.printf("[HTTP] Error code: %d\n", httpCode);
    }
  }
  else
  {
    Serial.printf("[HTTP] GET... failed, error: %s\n", http.errorToString(httpCode).c_str());
  }
  http.end();
  return result;
}

void sendIR(uint32_t Code)
{
  Serial.printf("Sending {0x%X}\n", Code);
  IrSender.sendPulseDistanceWidth(38, 9000, 4550, 600, 1700, 600, 550, Code, 24, PROTOCOL_IS_LSB_FIRST, 100, 0);
}

void setup()
{
  pinMode(ONE_WIRE_BUS, INPUT);
  pinMode(2, OUTPUT);

  // tempSensor.begin();
  // tempSensor.getAddress(sensorAddress, 0);
  // tempSensor.setResolution(sensorAddress, 11);
  Serial.begin(115200);
  IrSender.begin(false);
  int sensors_found = tempSensor.getDeviceCount();
  Serial.printf("DS18 SENSORS: %d\n", sensors_found);
  for (size_t i = 0; i < sensors_found; i++)
  {
    Serial.printf("[%d] 0x", i);
    DeviceAddress addr;
    tempSensor.getAddress(addr, i);
    for (size_t j = 0; j < 8; j++)
    {
      if (addr[j] < 0x10)
        Serial.print("0");
      Serial.print(addr[j], HEX);
    }
    Serial.println("");
  }
  Serial.printf("\n");
  Serial.print("Getting Internet Acess");

  // Wifi Setup
  WiFi.mode(WIFI_STA); // Important to be explicitly connected as client

#ifdef DEVICE_NAME
  WiFi.hostname(DEVICE_NAME);
#endif

  WiFi.begin(WIFISSID, WIFIPASSWD);
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(100);
    Serial.print(".");
  }

  Serial.println();
  Serial.print("Connection took (ms) : ");
  Serial.println(millis());
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
  server.on("/", handleRoot);
  server.on("/page.js", handleJS);
  server.on("/page.css", handleCSS);
  server.on("/send-ir", handleIRSend); // Handle IR code transmission
  server.on("/info", handleInfo);      // Handle IR code transmission
  server.begin();
  Serial.println("HTTP server started");

  // OTA
  ArduinoOTA.setHostname(DEVICE_NAME);
  ArduinoOTA.setPort(8266);
  ArduinoOTA.onStart(startOTA);
  ArduinoOTA.onEnd(endOTA);
  ArduinoOTA.onProgress(progressOTA);
  ArduinoOTA.onError(errorOTA);
  ArduinoOTA.begin(true);

  hive_client.setInsecure();
  HiveMQ.setServer(MQTT_URL, MQTT_PORT);
  HiveMQ.setCallback(HiveMQ_Callback);

  control_variables.time_synced = getTime();
  control_variables.boot_time = now();

  if (HiveMQ.connect(DEVICE_NAME, MQTT_USER, MQTT_PASSWD))
    Serial.println("MQTT Connected");
  else
    Serial.printf("Can't Connect to MQTT Error Code : %d\n", HiveMQ.state());
  HiveMQ.subscribe("Adler/#");
}

void loop()
{
  ArduinoOTA.handle();
  server.handleClient();
  HiveMQ.loop();

  if (now() - Timers.temperature > 2)
  {
    Timers.temperature = now();
    tempSensor.requestTemperatures();
    _current_temp = tempSensor.getTempCByIndex(0);
  }
  if (now() - Timers.sync_time > 300 && !control_variables.time_synced)
  {
    Timers.sync_time = now();
    control_variables.time_synced = getTime();
  }
  if (now() - Timers.mqtt_publish > 10)
  {
    Timers.mqtt_publish = now();
    String temp = String(_current_temp);
    HiveMQ.publish("Adler/Temperature", temp.c_str());
  }
  if (now() - Timers.mqtt_reconect > 300)
  {
    Timers.mqtt_reconnect = now();
    String temp = String(_current_temp);
    HiveMQ.publish("Adler/Temperature", temp.c_str());
  }
}
